#' @title A generator of Sampled Random Walks
#' It generates a list of n Sampled Random Walks along with the appropriate time period.
#' The time period goes from 0 up to T (0: time_to_maturity).
#' Because it is the same experiment for all the items of the list,
#' each of these depends on the same time period.
#' @param time_to_maturity - Number of time_to_maturity of the random walk
#' @param prob - Probability of occurence of head and tail for each step
#' @param scale - It defines the time partition between each unit of time.
#' For instance if the scale is 100, the time step [0,1] will be cut in 100 parts.
#' Furthermore this param defines the increment multiplier as well.
#' If the scale is 100, the multiplier which defines the next value will be
#' (+1 / -1) * 1/sqrt(100)
#' @param seed - With same seed, 2 exeriments will give the same output. It therefore
#' provides reproducibles experiments.
#' @param n - Number of samples generated by the function
#' @examples
#' # Generate a list of 20 sampled symmetric random walks
#' srwalkGenerator(n = 20)
#' @references
#' [1] Symmetric Random Walk, Stochastic Calculus for Finance, Steven e. Shreve, 2004, pp 83-84
#' @export
srwalkGenerator <- function(time_to_maturity = 100,
                            prob = c('head' = 0.5,
                                     'tail' = 0.5),
                            scale = 1,
                            seed = 1,
                            n = 1){

  # set.seed to get reproducible experiments
  set.seed(seed)

  # set the whole time step ----------------------------
  # The following has just to be set up once because it is the same one that
  # is used for all the random walk. Because all are indeed a different sample
  # of the same random walk.
  # TODO rename step -> partition
  step <- seq(from = 0,
              to = time_to_maturity,
              by = 1/scale)

  # All index (step * n) must be integer. Even it is probably not the optimal
  # way, I will round the value to get a sure integer value for (step * n)
  # step <- round(step * 100) / 100

  # Define the path constant multiplier ----------------------------
  multiplier <- 1 / sqrt(scale)

  # Construction of the random variable ----------------------------

  x <- rep(list(c(-1, 1)), n)

  X <- lapply(x,
              sample,
              size = time_to_maturity * scale,
              replace = T,
              prob = prob)

  Mk <- lapply(X, function(i){
    c(0,
      sapply(seq_along(i),
             function(x){
               sum(i[1:x]) * multiplier
             })
    )})

  sampledRandomWalk <- as.data.frame(Mk)

  # Construction of the x-axis ----------------------------
  # Based on the step variable, we get the x-axis for all different path
  # of the scaled random walk

  rwalkFactory <- function(x){
    a <- structure(data.frame(step, x),
                   class = c('sampled_randomwalk', class(data.frame())),
                   names = c('time_periods', 'random_walk_path'))
  }

  randomwalk <- structure(lapply(sampledRandomWalk, rwalkFactory ),
                          class = c('sampled_randomwalk', class(list())))

  if (n == 1) randomwalk[[1]]
  else randomwalk
}
