#' @title A generator of Sampled Brownian Motion
#'
#'
#' @description  It generates multiple (n) Sampled Brownian Motions - Wiener Process) along with
#'   the appropriate time period. The time period goes from 0 up to T (0:
#'   time_to_maturity).
#'
#'
#' @inheritParams sbmotion
#' @param n  Number of samples generated by the function
#'
#'
#' @examples
#' # Generate a list of 20 sampled Brownian Motions
#' sbmotionGenerator(n = 20)
#'
#'
#' @return \code{sbmotionGenerator()} outputs a \bold{list of data.frame}.
#' Each data.frame in the list contains the whole range of time period and
#' the value of the corresponding Brownian Motion at that time.
#'
#'
#' @references [1] Brownian Motion, Stochastic Calculus for Finance,
#'   Steven e. Shreve, 2004, pp 93-97
#'
#'
#' @export
#'
#' @importFrom magrittr %>%
sbmotionGenerator <- function(time_to_maturity = 4,
                              seed = 1,
                              scale = 100,
                              n = 1){


  ## Initialization of time variables.
  time_lower_bound <- 0
  time_upper_bound <- time_to_maturity * scale
  time_interval <- 1/scale
  time_step <- seq(0, time_to_maturity, by = time_interval)
  deltaT <- time_step[-1] - time_step[-length(time_step)]


  ## The time interval between each increment is needed in order to compute
  ## the variance of these increments. According to the theory, the variance is
  ## given by: var(W[t_i+1] - W[t_i]) = t_i+1 - t_i
  variance_increment <- deltaT
  sd_increment <- sqrt(variance_increment)


  ## Each value taken by the brownian motion agrees with the following properties
  ## of the increments of the brownian motion:
  ## E[increment] = 0
  ## var(increment) = delta(time)
  set.seed(seed)

  ## The following genereates a list of n items. Each one containing vector of
  ## numbers generated randomly according to the Normal Law N~(0, sd_increment)
  number_of_occurence <- time_upper_bound * n

  # See import magrittr::'%>%' (and  also dplyr::'%>%', purrr::%>%)
  normally_distributed_increment <-  rnorm(n = number_of_occurence,
                                           mean = 0,
                                           sd = sd_increment) %>%
    split(ceiling(seq_along(.) / time_upper_bound ))

  ## Cumulative sum of each vector of the previously created list in ordre to
  ## capture the evolution of a cumulative process (Brownian Motion)
  bm <- lapply(normally_distributed_increment, cumsum)


  ## As theorical lecture state: the brownian motion initial value is 0.
  ## An interesting case TODO will be to implement brownian motion with another
  ## initial value than 0.
  anonymous <- function(bmotion){
    structure(data.frame('time_periods' = time_step,
                         'brownian_motion_path' = c(0,bmotion)),
              class = c('sampled_brownianmotion', class(data.frame())),
              scale = scale)
  }

  ## Simplify the output if the number of path =1. It seems to be overkill to
  ## provide a list of one data.frame. A unique data.frame does the job
  brownianmotion <- structure(lapply(bm, anonymous),
                              class = c('sampled_brownianmotion', class(list())),
                              scale = scale)
  if (n == 1) brownianmotion[[1]]
  else brownianmotion
}
